package net.natga999.wynn_ai.path;

import net.minecraft.block.*;
import net.minecraft.block.enums.BlockHalf;
import net.minecraft.block.enums.SlabType;
import net.minecraft.util.math.Vec3d;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;

import java.util.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

//   generated by gemini - code blocks possibly from here:
//   https://github.com/AztechMC/Modern-Industrialization
//   https://github.com/Lehirti/Lehirti-Game-Engine
//   https://github.com/AntiCope/meteor-rejects

public class PathFinder {
    private static final Logger LOGGER = LoggerFactory.getLogger(PathFinder.class);
    private final ClientWorld world;
    private final ChunkCache cache;
    private final int maxDrop;  // maximum safe drop height
    private static final int MAX_PATH_LENGTH = 5000; // Maximum number of nodes to explore
    private static final double CORNER_OFFSET = 0.2; // amount to soften 90Â° turns
    private final BlockPos start;
    private final BlockPos goal;

    public PathFinder(ClientWorld world, int cacheRadius, BlockPos start, BlockPos goal) {
        this(world, cacheRadius, start, goal, 3); // Default max drop of 3 blocks
    }

    public PathFinder(ClientWorld world, int cacheRadius, BlockPos start, BlockPos goal, int maxDrop) {
        this.world = world;
        this.cache = new ChunkCache(world, start, cacheRadius);
        this.start   = start;
        this.goal    = goal;
        this.maxDrop = maxDrop;
        LOGGER.debug("PathFinder initialized with cache radius {} and max drop {}", cacheRadius, maxDrop);
    }

    public List<Vec3d> findPath(BlockPos start, BlockPos goal) {
        LOGGER.info("Finding path from {} to {}", start, goal);

        Map<BlockPos, Double> gScore = new HashMap<>();
        gScore.put(start, 0.0);

        // Check if start and goal are within cache bounds
        if (!cache.isWithinCacheBounds(start)) {
            LOGGER.debug("Start position {} is outside cache bounds", start);
            return null;
        }

        if (!cache.isWithinCacheBounds(goal)) {
            LOGGER.debug("Goal position {} is outside cache bounds", goal);
            return null;
        }

        // Nodes to explore and the ones already explored
        PriorityQueue<Node> openSet = new PriorityQueue<>(Comparator.comparingDouble(Node::getF));
        HashSet<BlockPos> closedSet = new HashSet<>();

        // Start node
        Node startNode = new Node(start, 0, estimateDistance(start, goal));
        openSet.add(startNode);

        int iterations = 0;
        int nodesExpanded = 0;

        // Path finding loop
        while (!openSet.isEmpty()) {
            iterations++;

            // Check if we've explored too many nodes
            if (closedSet.size() > MAX_PATH_LENGTH) {
                LOGGER.debug("Path search aborted - exceeded maximum path length ({} nodes explored)", MAX_PATH_LENGTH);
                return null; // Path too long, abort
            }

            Node current = openSet.poll();
            nodesExpanded++;

            // Check if goal is found
            if (current.getPos().equals(goal)) {
                List<BlockPos> rawPath = reconstructPath(current);
                List<Vec3d> simplifiedPath = simplifyPath(rawPath);
                List<Vec3d> curvedPath = postProcessCorners(simplifiedPath);
                LOGGER.info("Simplified path from {} to {} nodes", rawPath.size(), curvedPath.size());
                return curvedPath;
            }

            closedSet.add(current.getPos());

            // Explore 8 planar neighbors (N, NE, E, SE, S, SW, W, NW)
            int validNeighbors = 0;
            // Explore 8 planar neighbors (N, NE, E, SE, S, SW, W, NW)
            // int validNeighbors = 0; // validNeighbors is incremented when a node is actually added
            // Offsets for the 8 directions in XZ plane
            int[] dx = {  0,  1,  1,  1,  0, -1, -1, -1 };
            int[] dz = {  1,  1,  0, -1, -1, -1,  0,  1 };

            for (int i = 0; i < 8; i++) {
                BlockPos horizPos = current.getPos().add(dx[i], 0, dz[i]);

                if (!cache.isWithinCacheBounds(horizPos)) continue;

                // Corner-cut prevention for the step from current.getPos() to horizPos.
                // This gates whether horizPos (and candidates derived from it) are even considered.
                if (Math.abs(dx[i]) == 1 && Math.abs(dz[i]) == 1) {
                    BlockPos sideA = current.getPos().add(dx[i], 0, 0);
                    BlockPos sideB = current.getPos().add(0, 0, dz[i]);
                    boolean sideAClear = isLadder(sideA) ? isSpaceClearForLadder(sideA) : isSpaceClear(sideA);
                    boolean sideBClear = isLadder(sideB) ? isSpaceClearForLadder(sideB) : isSpaceClear(sideB);
                    if (!sideAClear || !sideBClear) {
                        LOGGER.trace("Corner cut failed for horizPos {} from {}", horizPos, current.getPos());
                        continue; // Skip this horizPos entirely
                    }
                }

                // Option 1: Consider ground found by findGroundBelow(horizPos)
                BlockPos groundCandidate = findGroundBelow(horizPos);
                if (groundCandidate != null) {
                    if (!closedSet.contains(groundCandidate)) {
                        boolean canMoveToGroundCandidate = true;
                        // Headspace check for jump/drop: if horizPos is stepped through to reach groundCandidate
                        // This check is important if horizPos itself isn't the final destination but an intermediate air block for a jump/drop.
                        if (!isLadder(groundCandidate) && !isSpaceClear(horizPos.up())) {
                            LOGGER.trace("Headspace blocked at {}.up for move to groundCandidate {}", horizPos, groundCandidate);
                            canMoveToGroundCandidate = false;
                        }
                        // Target space clearance
                        if (canMoveToGroundCandidate) {
                            if (isLadder(groundCandidate) ? !isSpaceClearForLadder(groundCandidate) : !isSpaceClear(groundCandidate)) {
                                LOGGER.trace("Target space {} not clear for groundCandidate {}", groundCandidate, (isLadder(groundCandidate) ? "(ladder)" : "(normal)"));
                                canMoveToGroundCandidate = false;
                            }
                        }

                        if (canMoveToGroundCandidate) {
                            double tentativeG = current.getG() + movementCost(current.getPos(), groundCandidate);
                            if (!gScore.containsKey(groundCandidate) || tentativeG < gScore.get(groundCandidate)) {
                                gScore.put(groundCandidate, tentativeG);
                                openSet.add(new Node(groundCandidate, tentativeG, estimateDistance(groundCandidate, goal), current));
                                validNeighbors++; // Incremented because a valid node option was found and added
                                LOGGER.trace("Added groundCandidate {} from {} via horizPos {}", groundCandidate, current.getPos(), horizPos);
                            }
                        }
                    }
                }

                // Option 2: Consider horizPos itself if it's an air block above a ladder.
                // This allows stepping onto the spot right above a ladder to initiate a climb down.
                BlockState horizState = cache.getBlockState(horizPos);
                if (horizState != null && horizState.isAir()) {
                    BlockPos belowHoriz = horizPos.down();
                    // Check if horizPos is a suitable air block to step into for climbing down a ladder
                    if (isLadder(belowHoriz) && isSpaceClearForLadder(horizPos)) {
                        BlockPos airAboveLadderCandidate = horizPos; // This is horizPos itself

                        if (!closedSet.contains(airAboveLadderCandidate)) {
                            // isSpaceClearForLadder(airAboveLadderCandidate) is already confirmed true
                            double tentativeG = current.getG() + movementCost(current.getPos(), airAboveLadderCandidate);
                            if (!gScore.containsKey(airAboveLadderCandidate) || tentativeG < gScore.get(airAboveLadderCandidate)) {
                                gScore.put(airAboveLadderCandidate, tentativeG);
                                openSet.add(new Node(airAboveLadderCandidate, tentativeG, estimateDistance(airAboveLadderCandidate, goal), current));
                                validNeighbors++; // Incremented because a valid node option was found and added
                                LOGGER.trace("Added airAboveLadderCandidate {} from {}", airAboveLadderCandidate, current.getPos());
                            }
                        }
                    }
                }
            }

            // Consider jumping up one block if possible
            BlockPos upPos = current.getPos().up();
            if (cache.isWithinCacheBounds(upPos) && !closedSet.contains(upPos)) {
                // Can only jump up from a solid block
                BlockState currentBlockStateBelow = cache.getBlockState(current.getPos().down());
                if (canJumpFrom(currentBlockStateBelow)) {
                    // Check if space above is clear for jumping
                    if (isSpaceClear(upPos)) {
                        validNeighbors++;
                        double jumpIncrement = movementCost(current.getPos(), upPos);
                        double jumpCost      = current.getG() + jumpIncrement;
                        openSet.add(new Node(upPos, jumpCost, estimateDistance(upPos, goal), current));
                    } else {
                        LOGGER.debug("Can't jump up at {} - space not clear", current.getPos());
                    }
                } else {
                    LOGGER.debug("Can't jump up at {} - not standing on solid block", current.getPos());
                }
            }

            // Consider climbing ladders
            BlockPos currentPos = current.getPos();
            // BlockState currentBlockState = cache.getBlockState(currentPos); // Already fetched if needed for climbDown

            // Climbing Up a Ladder
            if (isLadder(currentPos)) { // Current position is a ladder
                BlockPos ladderUp = currentPos.up(); // Potential next position (feet)

                if (cache.isWithinCacheBounds(ladderUp) && !closedSet.contains(ladderUp)) {
                    BlockState ladderUpState = cache.getBlockState(ladderUp);
                    if (ladderUpState != null) { // Ensure block state is available
                        // To climb to ladderUp:
                        // 1. ladderUp must itself be a ladder block or an air block (for exiting).
                        // 2. The 2-block high space for the player, if their feet were at ladderUp, must be clear in a ladder context.
                        if ((isLadder(ladderUp) || ladderUpState.isAir()) && isSpaceClearForLadder(ladderUp)) {
                            validNeighbors++;
                            double climbCost = current.getG() + movementCost(currentPos, ladderUp);
                            if (!gScore.containsKey(ladderUp) || climbCost < gScore.get(ladderUp)) {
                                gScore.put(ladderUp, climbCost);
                                openSet.add(new Node(ladderUp, climbCost, estimateDistance(ladderUp, goal), current));
                                LOGGER.debug("Added ladder climb up option from {} to {}", currentPos, ladderUp);
                            }
                        } else {
                            LOGGER.debug("Cannot climb up from {} to {}: target block type or space for entity not suitable for ladder.", currentPos, ladderUp);
                        }
                    }
                }
            }

            // Climbing Down a Ladder (ensure currentBlockState is fetched if not already)
            BlockState currentBlockState = cache.getBlockState(currentPos); // Moved here or ensure it's available
            BlockPos ladderDown = currentPos.down();
            if (cache.isWithinCacheBounds(ladderDown) && !closedSet.contains(ladderDown)) {
                boolean canClimbDown = false;
                if (isLadder(ladderDown) && isSpaceClearForLadder(currentPos) && (isLadder(currentPos) || (currentBlockState != null && currentBlockState.isAir()))) {
                    canClimbDown = true;
                }

                if (canClimbDown) {
                    validNeighbors++;
                    double climbCost = current.getG() + movementCost(currentPos, ladderDown);
                    if (!gScore.containsKey(ladderDown) || climbCost < gScore.get(ladderDown)) {
                        gScore.put(ladderDown, climbCost);
                        openSet.add(new Node(ladderDown, climbCost, estimateDistance(ladderDown, goal), current));
                        LOGGER.debug("Added ladder climb down option from {} to {}", currentPos, ladderDown);
                    }
                }
            }

            // ... (after regular ladder climbing logic)

            // Consider "ladder-top-hop": jumping/stepping onto the top of a ladder
            // and then immediately considering a jump up from there.
            // This is for when a ladder is one block short of a ledge.
            if (!isLadder(currentPos) && canJumpFrom(cache.getBlockState(currentPos.down()))) { // Must be on solid ground to initiate this
                for (int i = 0; i < 8; i++) { // Check horizontal neighbors for a ladder top
                    BlockPos ladderTopCandidatePos = current.getPos().add(dx[i], 0, dz[i]); // Horizontal position
                    BlockPos ladderBlockBelow = ladderTopCandidatePos.down(); // The ladder block itself

                    if (!cache.isWithinCacheBounds(ladderBlockBelow) || !isLadder(ladderBlockBelow)) {
                        continue; // Not a ladder below the horizontal candidate
                    }

                    // ladderTopCandidatePos is the air block directly above the ladderBlockBelow.
                    // Check if we can "land" or be at ladderTopCandidatePos (the air block above the ladder)
                    // For this specific maneuver, the "standing" spot is effectively the top edge of ladderBlockBelow.
                    // The entity's feet would be in ladderTopCandidatePos.
                    if (isSpaceClearForLadder(ladderTopCandidatePos)) { // Can the player occupy this air space above the ladder?

                        // Now, from this ladderTopCandidatePos (air above ladder), can we jump one block up?
                        BlockPos jumpTargetPos = ladderTopCandidatePos.up();
                        BlockPos surfaceBelowJumpTarget = jumpTargetPos.down(); // This should be ladderTopCandidatePos

                        if (cache.isWithinCacheBounds(jumpTargetPos) && !closedSet.contains(jumpTargetPos) &&
                                isSpaceClear(jumpTargetPos)) { // Standard space clear for the jump destination

                            // The "jump from" surface is effectively the top of the ladder (ladderBlockBelow).
                            // We don't need a canJumpFrom() check here in the traditional sense,
                            // as the ability to be at ladderTopCandidatePos implies we can initiate a jump.

                            // Cost: cost to move to ladderTopCandidatePos + cost to jump to jumpTargetPos
                            double costToLadderAir = movementCost(current.getPos(), ladderTopCandidatePos);
                            double costToJump = movementCost(ladderTopCandidatePos, jumpTargetPos);
                            double tentativeG = current.getG() + costToLadderAir + costToJump;

                            if (!gScore.containsKey(jumpTargetPos) || tentativeG < gScore.get(jumpTargetPos)) {
                                // We need an intermediate node for the path reconstruction to make sense,
                                // or we need to ensure the path simplifier can handle this.
                                // For A*, it's better to add the actual sequence.

                                // Create a temporary parent node representing being on top of the ladder
                                // This node won't be added to openSet directly but used as parent for jumpTargetPos
                                Node ladderAirNode = new Node(ladderTopCandidatePos, current.getG() + costToLadderAir, estimateDistance(ladderTopCandidatePos, goal), current);

                                gScore.put(jumpTargetPos, tentativeG);
                                // The parent of jumpTargetPos should be the conceptual node of being at ladderTopCandidatePos
                                // For simplicity in A*, we can add ladderTopCandidatePos first if it's not already optimally reached,
                                // and then from ladderTopCandidatePos, the jumpTargetPos would be a natural jump.

                                // Let's try adding ladderTopCandidatePos first, then the jump will be handled when it becomes current.
                                // This is cleaner for A*.
                                double gScoreLadderAir = current.getG() + costToLadderAir;
                                if(!closedSet.contains(ladderTopCandidatePos) && (!gScore.containsKey(ladderTopCandidatePos) || gScoreLadderAir < gScore.get(ladderTopCandidatePos))) {
                                    gScore.put(ladderTopCandidatePos, gScoreLadderAir);
                                    openSet.add(new Node(ladderTopCandidatePos, gScoreLadderAir, estimateDistance(ladderTopCandidatePos, goal), current));
                                    validNeighbors++;
                                    LOGGER.debug("Added ladder-top-air candidate {} for potential hop from {}", ladderTopCandidatePos, current.getPos());
                                }
                                // The jump from ladderTopCandidatePos to jumpTargetPos will be handled
                                // when ladderTopCandidatePos is processed from the openSet, via the standard "jump up" logic,
                                // provided canJumpFrom() can be true when standing in air above a ladder.

                                // To make the jump from air above ladder work with current canJumpFrom:
                                // We need to ensure that when currentPos is ladderTopCandidatePos,
                                // currentPos.down() (which is ladderBlockBelow) is seen as something jumpable.
                                // Let's modify canJumpFrom slightly.
                            }
                        }
                    }
                }
            }

            if (validNeighbors == 0 && iterations % 100 == 0) {
                LOGGER.debug("No valid neighbors for position {} after {} iterations", current.getPos(), iterations);
            }

            if (iterations % 1000 == 0) {
                LOGGER.debug("Pathfinding in progress - {} iterations, {} nodes in closed set, {} nodes in open set",
                        iterations, closedSet.size(), openSet.size());
            }
        }

        LOGGER.warn("No path found after {} iterations, {} nodes expanded", iterations, nodesExpanded);
        return null; // No path found
    }

    // New helper method to check if a block is a ladder
    private boolean isLadder(BlockPos pos) {
        if (!cache.isWithinCacheBounds(pos)) return false;
        BlockState state = cache.getBlockState(pos);
        return state != null && state.getBlock() instanceof LadderBlock;
    }

    // New helper method to check if space is clear for ladder movement
    // The entity is considered to be "inside" the ladder block or the air block it steps into.
    // This checks if an entity with feet at 'pos' has clearance for both feet and head in a ladder context.
    private boolean isSpaceClearForLadder(BlockPos pos) {
        // Check if the entity's feet position (pos) is valid for being on a ladder
        if (!cache.isWithinCacheBounds(pos)) {
            LOGGER.debug("Position (isSpaceClearForLadder feet) {} is outside cache bounds", pos);
            return false;
        }
        BlockState blockAtFeet = cache.getBlockState(pos);
        if (blockAtFeet == null) {
            LOGGER.debug("Missing block state at {} (feet) for ladder check", pos);
            return false;
        }

        // Feet must be in a ladder block or an air block (e.g., when moving into an empty ladder column space or stepping off)
        boolean feetOk = blockAtFeet.getBlock() instanceof LadderBlock || blockAtFeet.isAir();
        if (!feetOk) {
            LOGGER.debug("Space not clear for ladder at {} (feet): block is {} - not ladder or air", pos, blockAtFeet);
            return false;
        }

        // Check if the entity's head position (pos.up()) is also valid for being on a ladder
        BlockPos headPos = pos.up();
        if (!cache.isWithinCacheBounds(headPos)) {
            LOGGER.debug("Position (isSpaceClearForLadder head) {} is outside cache bounds", headPos);
            return false;
        }
        BlockState blockAtHead = cache.getBlockState(headPos);
        if (blockAtHead == null) {
            LOGGER.debug("Missing block state at {} (head) for ladder check", headPos);
            return false;
        }

        // Head must also be in a ladder block or an air block.
        boolean headOk = blockAtHead.isAir() || blockAtHead.getBlock() instanceof LadderBlock;
        if (!headOk) {
            LOGGER.debug("Space not clear for ladder at {} (head): block is {} - not air or ladder", headPos, blockAtHead);
            return false;
        }

        return true; // Both feet and head positions are suitable for an entity at 'pos' on a ladder.
    }

    public List<Vec3d> simplifyPath(List<BlockPos> rawPath) {
        if (rawPath.size() <= 2) {
            List<Vec3d> direct = new ArrayList<>(rawPath.size());
            for (BlockPos p : rawPath) direct.add(toVec3(p, null)); // Pass null for previous block initially
            return direct;
        }

        List<Vec3d> simplified = new ArrayList<>();
        simplified.add(toVec3(rawPath.getFirst(), null)); // First point has no predecessor

        int currentIndex = 0;
        while (currentIndex < rawPath.size() - 1) {
            BlockPos lastAddedBlock = rawPath.get(currentIndex);
            Vec3d lastVec = simplified.getLast();

            int farthestValid = currentIndex + 1;
            for (int i = currentIndex + 1; i < rawPath.size(); i++) {
                BlockPos candidateBlockInRawPath = rawPath.get(i);
                if (isRaycastWalkable(lastAddedBlock, candidateBlockInRawPath)) {
                    farthestValid = i;
                } else {
                    break;
                }
            }

            BlockPos nextBlockRaw = rawPath.get(farthestValid);
            // When converting the next block, pass the lastAddedBlock to toVec3 for context
            Vec3d nextVecTarget = toVec3(nextBlockRaw, lastAddedBlock);

            int dy = lastAddedBlock.getY() - nextBlockRaw.getY();
            boolean lastIsLadder = isLadder(lastAddedBlock);
            boolean nextIsLadder = isLadder(nextBlockRaw);

            if (dy >= 2 && !lastIsLadder && !nextIsLadder) {
                Vec3d directionToNextRaw = toVec3(nextBlockRaw, lastAddedBlock).subtract(toVec3(lastAddedBlock, (currentIndex > 0 ? rawPath.get(currentIndex -1) : null) ));
                Vec3d edgeVec = toVec3(lastAddedBlock, (currentIndex > 0 ? rawPath.get(currentIndex -1) : null)).add(directionToNextRaw.normalize().multiply(0.5 * Math.sqrt(lastAddedBlock.getSquaredDistance(nextBlockRaw))));
                edgeVec = new Vec3d(edgeVec.x, lastAddedBlock.getY() + 0.5, edgeVec.z);

                if (edgeVec.squaredDistanceTo(lastVec) > 0.01) {
                    simplified.add(edgeVec);
                }

                if (farthestValid + 1 < rawPath.size()) {
                    BlockPos nextNextBlockRaw = rawPath.get(farthestValid + 1);
                    // Vec3d nextNextVecRaw = toVec3(nextNextBlockRaw, nextBlockRaw); // Pass nextBlockRaw as previous

                    Vec3d toNextNext = toVec3(nextNextBlockRaw, nextBlockRaw).subtract(nextVecTarget); // Recalculate nextVecTarget if it was adjusted
                    Vec3d toNextNextXZ = new Vec3d(toNextNext.x, 0, toNextNext.z).normalize();

                    double landingOffsetAmount = 0.5;
                    nextVecTarget = new Vec3d(
                            nextVecTarget.x + toNextNextXZ.x * landingOffsetAmount,
                            nextVecTarget.y,
                            nextVecTarget.z + toNextNextXZ.z * landingOffsetAmount
                    );
                }
            }
            simplified.add(nextVecTarget);
            currentIndex = farthestValid;
        }
        return simplified;
    }

    /**
     * Convert BlockPos to Vec3d, centering within the block.
     * @param pos The current BlockPos to convert.
     * @param prevPos The previous BlockPos in the path, or null if this is the start.
     */
    private Vec3d toVec3(BlockPos pos, BlockPos prevPos) {
        BlockState state = cache.getBlockState(pos);
        double x = pos.getX() + 0.5;
        double y = pos.getY() + 0.5;
        double z = pos.getZ() + 0.5;

        boolean aligned = false;

        if (state != null && state.getBlock() instanceof LadderBlock) {
            // Current block is a ladder, align to it
            Direction facing = state.get(LadderBlock.FACING);
            double ladderDepthOffset = 0.4;
            switch (facing) {
                case NORTH: z += ladderDepthOffset; break;
                case SOUTH: z -= ladderDepthOffset; break;
                case WEST:  x += ladderDepthOffset; break;
                case EAST:  x -= ladderDepthOffset; break;
                default: break;
            }
            aligned = true;
        } else if (state != null && state.isAir()) {
            // Current block is air. Check context for ladder alignment.
            BlockState prevBlockState = (prevPos != null) ? cache.getBlockState(prevPos) : null;

            if (prevPos != null && prevBlockState != null && prevBlockState.getBlock() instanceof LadderBlock) {
                // Case 1: Previous was a ladder, current is air (exiting ladder upwards)
                Direction ladderFacing = prevBlockState.get(LadderBlock.FACING);
                double ladderDepthOffset = 0.4;
                x = prevPos.getX() + 0.5; // Align with previous ladder's center
                z = prevPos.getZ() + 0.5;
                switch (ladderFacing) {
                    case NORTH: z += ladderDepthOffset; break;
                    case SOUTH: z -= ladderDepthOffset; break;
                    case WEST:  x += ladderDepthOffset; break;
                    case EAST:  x -= ladderDepthOffset; break;
                    default: break;
                }
                aligned = true;
            } else {
                // Case 2: Current is air, check if block BELOW is a ladder (preparing to climb down)
                BlockPos belowPos = pos.down();
                BlockState belowState = cache.getBlockState(belowPos);
                if (belowState != null && belowState.getBlock() instanceof LadderBlock) {
                    Direction ladderFacing = belowState.get(LadderBlock.FACING);
                    double ladderDepthOffset = 0.4;
                    // Align with the ladder below's center
                    x = belowPos.getX() + 0.5;
                    z = belowPos.getZ() + 0.5;
                    switch (ladderFacing) {
                        case NORTH: z += ladderDepthOffset; break;
                        case SOUTH: z -= ladderDepthOffset; break;
                        case WEST:  x += ladderDepthOffset; break;
                        case EAST:  x -= ladderDepthOffset; break;
                        default: break;
                    }
                    aligned = true;
                } else if (prevPos != null && prevBlockState != null && prevBlockState.isAir()) {
                    // Case 3: Current is air, previous was also air.
                    // This could be the second air block in a "ladder-top-hop" jump.
                    // Check if prevPos.down() was a ladder.
                    BlockPos belowPrevPos = prevPos.down();
                    BlockState belowPrevState = cache.getBlockState(belowPrevPos);
                    if (belowPrevState != null && belowPrevState.getBlock() instanceof LadderBlock) {
                        // Align with the ladder that was below the previous air block
                        Direction ladderFacing = belowPrevState.get(LadderBlock.FACING);
                        double ladderDepthOffset = 0.4;
                        x = belowPrevPos.getX() + 0.5; // Align with that ladder's center
                        z = belowPrevPos.getZ() + 0.5;
                        switch (ladderFacing) {
                            case NORTH: z += ladderDepthOffset; break;
                            case SOUTH: z -= ladderDepthOffset; break;
                            case WEST:  x += ladderDepthOffset; break;
                            case EAST:  x -= ladderDepthOffset; break;
                            default: break;
                        }
                        aligned = true;
                    }
                }
            }
        }
        // If the current block 'pos' is NOT air and NOT a ladder, but the prevPos was air
        // and that prevPos was aligned to a ladder, we might want to align 'pos' as well if it's directly above.
        // This handles the final landing block of the ladder-top-hop.
        else if (state != null && !state.isAir() && !(state.getBlock() instanceof LadderBlock) && prevPos != null) {
            BlockState prevBlockState = cache.getBlockState(prevPos);
            if (prevBlockState != null && prevBlockState.isAir() && pos.getY() == prevPos.getY() + 1 && pos.getX() == prevPos.getX() && pos.getZ() == prevPos.getZ()) {
                // Current is solid, previous was air directly below current.
                // Check if prevPos was aligned due to a ladder further below it.
                BlockPos belowPrevPos = prevPos.down();
                BlockState belowPrevState = cache.getBlockState(belowPrevPos);
                if (belowPrevState != null && belowPrevState.getBlock() instanceof LadderBlock) {
                    // Align current 'pos' with the ladder that was below 'prevPos'
                    Direction ladderFacing = belowPrevState.get(LadderBlock.FACING);
                    double ladderDepthOffset = 0.4;
                    x = belowPrevPos.getX() + 0.5; // Align with that ladder's center
                    z = belowPrevPos.getZ() + 0.5;
                    switch (ladderFacing) {
                        case NORTH: z += ladderDepthOffset; break;
                        case SOUTH: z -= ladderDepthOffset; break;
                        case WEST:  x += ladderDepthOffset; break;
                        case EAST:  x -= ladderDepthOffset; break;
                        default: break;
                    }
                    aligned = true;
                }
            }
        }

        return new Vec3d(x, y, z);
    }
    /**
     * Post-process waypoints to soften 90Â° corners by replacing the corner point
     * with a point offset from the corner in both directions.
     */
    private List<Vec3d> postProcessCorners(List<Vec3d> path) {
        if (path.size() < 3) return path;
        List<Vec3d> result = new ArrayList<>();
        result.add(path.getFirst());

        for (int i = 1; i < path.size() - 1; i++) {
            Vec3d prev = path.get(i - 1);
            Vec3d curr = path.get(i);
            Vec3d next = path.get(i + 1);

            // Approximate BlockPos from Vec3d to check for ladder
            BlockPos currBlock = BlockPos.ofFloored(curr.x, curr.y, curr.z);
            BlockPos prevBlock = BlockPos.ofFloored(prev.x, prev.y, prev.z);
            // BlockPos nextBlock = BlockPos.ofFloored(next.x, next.y, next.z); // Not strictly needed for this logic

            // Don't smooth corners if current or previous was part of a ladder interaction
            // This helps maintain the straight alignment when getting on/off ladders.
            boolean currIsLadder = isLadder(currBlock);
            boolean prevIsLadder = isLadder(prevBlock);
            // Also check if curr is air directly above a ladder (prevBlock)
            boolean currIsAirAboveLadder = currBlock.getY() == prevBlock.getY() + 1 && prevIsLadder && cache.getBlockState(currBlock).isAir();


            if (currIsLadder || prevIsLadder || currIsAirAboveLadder) {
                // More specific check for vertical ladder segments to avoid any smoothing
                if (currIsLadder && prevIsLadder && Math.abs(prev.getX() - curr.getX()) < 0.1 && Math.abs(prev.getZ() - curr.getZ()) < 0.1) {
                    result.add(curr);
                    continue;
                }
                // If it's an on/off ladder transition or moving from ladder to air above it, don't smooth.
                if ((currIsLadder != prevIsLadder) || currIsAirAboveLadder) {
                    result.add(curr);
                    continue;
                }
            }


            Vec3d dirPrev = curr.subtract(prev).normalize();
            Vec3d dirNext = next.subtract(curr).normalize();

            // Detect orthogonal turn (dot product ~0)
            if (Math.abs(dirPrev.dotProduct(dirNext)) < 0.01 && !currIsLadder && !prevIsLadder) { // Only smooth non-ladder turns
                // Replace corner with a single point offset from both directions
                Vec3d offset = curr.subtract(dirPrev.multiply(CORNER_OFFSET))
                        .add(dirNext.multiply(CORNER_OFFSET));
                result.add(offset);
            } else {
                result.add(curr);
            }
        }

        result.add(path.getLast());
        return result;
    }

    private boolean isRaycastWalkable(BlockPos start, BlockPos end) {
        List<BlockPos> line = getBlocksBetween(start, end);
        for (int i = 0; i < line.size(); i++) {
            BlockPos pos = line.get(i);
            // Ensure position is within cached chunks
            if (!cache.isWithinCacheBounds(pos)) {
                return false;
            }

            BlockState blockState = cache.getBlockState(pos);
            if (blockState == null) return false;

            if (isLadder(pos)) {
                // For a ladder block to be "walkable" in a raycast,
                // not only the ladder block itself but the space above it (for head) must be clear (air or another ladder)
                if (!isSpaceClearForLadder(pos)) return false;


                if (i + 1 < line.size()) {
                    BlockPos nextPosInLine = line.get(i+1);
                    BlockState nextBlockStateInLine = cache.getBlockState(nextPosInLine);
                    if (nextBlockStateInLine == null) return false;

                    if (nextPosInLine.getY() != pos.getY()) { // Moving vertically
                        // If next is also a ladder, it's fine. If it's air, it's also fine (exiting top).
                        // If it's something else, it's a blockage.
                        if (!isLadder(nextPosInLine) && !nextBlockStateInLine.isAir()) {
                            return false;
                        }
                        // Additionally, if exiting to air, ensure two blocks of air for player height
                        if (nextBlockStateInLine.isAir()) {
                            BlockPos twoUpFromCurrentLadder = pos.up(2);
                            if(!cache.isWithinCacheBounds(twoUpFromCurrentLadder) || !cache.getBlockState(twoUpFromCurrentLadder).isAir()){
                                return false; // Not enough space to exit ladder
                            }
                        }
                    }
                    else if (nextPosInLine.getX() != pos.getX() || nextPosInLine.getZ() != pos.getZ()) {
                        // Moving horizontally off a ladder
                        if (!isLadder(nextPosInLine) && !isSpaceClear(nextPosInLine)) {
                            return false;
                        }
                    }
                } else if (i == line.size() -1 && isLadder(pos)) {
                    // If the very last block of the raycast is a ladder, ensure space above it to stand
                    BlockPos oneUp = pos.up();
                    BlockPos twoUp = pos.up(2);
                    if (!cache.isWithinCacheBounds(oneUp) || !cache.getBlockState(oneUp).isAir() ||
                            !cache.isWithinCacheBounds(twoUp) || !cache.getBlockState(twoUp).isAir()){
                        return false; // Not enough space to stand after climbing this ladder
                    }
                }
                continue;
            }

            // Check ground stability (if not a ladder)
            BlockPos groundPos = pos.down();
            if (!isGroundWalkable(groundPos)) {
                return false;
            }

            // Check if the space at this position is clear (feet and head)
            if (!isSpaceClear(pos)) {
                return false;
            }
        }
        return true;
    }

    private boolean isGroundWalkable(BlockPos pos) {
        BlockState state = cache.getBlockState(pos);
        return state != null &&
                (state.isSideSolidFullSquare(world, pos, Direction.UP)
                        || state.getBlock() instanceof StairsBlock
                        || state.getBlock() instanceof SlabBlock
                        || (state.getBlock() instanceof SnowBlock && state.get(SnowBlock.LAYERS) == SnowBlock.MAX_LAYERS) // Only full snow blocks
                        || state.getBlock() instanceof CarpetBlock // Carpets are thin, stand on block below
                        || state.getBlock() instanceof FarmlandBlock);
    }

    /**
     * Voxel traversal that never skips orthogonal neighbors on diagonal moves.
     * Based on Amanatides & Woo, but handles ties by inserting both axisâsteps.
     */
    private List<BlockPos> getBlocksBetween(BlockPos start, BlockPos end) {
        List<BlockPos> blocks = new ArrayList<>();
        double x0 = start.getX() + 0.5, y0 = start.getY() + 0.5, z0 = start.getZ() + 0.5;
        double dx = end.getX() - start.getX();
        double dy = end.getY() - start.getY();
        double dz = end.getZ() - start.getZ();

        int stepX = dx>0?1:-1, stepY = dy>0?1:-1, stepZ = dz>0?1:-1;
        // Handle division by zero if dx, dy, or dz is 0
        double tDeltaX = (dx == 0) ? Double.POSITIVE_INFINITY : Math.abs(1.0 / dx);
        double tDeltaY = (dy == 0) ? Double.POSITIVE_INFINITY : Math.abs(1.0 / dy);
        double tDeltaZ = (dz == 0) ? Double.POSITIVE_INFINITY : Math.abs(1.0 / dz);


        double tMaxX = (dx == 0) ? Double.POSITIVE_INFINITY : (stepX>0
                ? (Math.floor(x0)+1 - x0) * tDeltaX
                : (x0 - Math.floor(x0))   * tDeltaX);
        double tMaxY = (dy == 0) ? Double.POSITIVE_INFINITY : (stepY>0
                ? (Math.floor(y0)+1 - y0) * tDeltaY
                : (y0 - Math.floor(y0))   * tDeltaY);
        double tMaxZ = (dz == 0) ? Double.POSITIVE_INFINITY : (stepZ>0
                ? (Math.floor(z0)+1 - z0) * tDeltaZ
                : (z0 - Math.floor(z0))   * tDeltaZ);

        int ix = start.getX(), iy = start.getY(), iz = start.getZ();

        while (true) {
            blocks.add(new BlockPos(ix, iy, iz));
            if (ix==end.getX() && iy==end.getY() && iz==end.getZ()) break;

            // Find the smallest tMax
            double min = Math.min(tMaxX, Math.min(tMaxY, tMaxZ));
            if (min == Double.POSITIVE_INFINITY) { // Should only happen if start == end, handled by initial check
                break;
            }


            boolean stepXNow = Math.abs(tMaxX - min) < 1e-9; // Compare doubles with tolerance
            boolean stepYNow = Math.abs(tMaxY - min) < 1e-9;
            boolean stepZNow = Math.abs(tMaxZ - min) < 1e-9;


            // If two (or three) axes tie, weâll step eachâand insert the orthogonal blocks first.
            // e.g. stepping X and Z diagonally, insert (ix+stepX,iy,iz) and (ix,iy,iz+stepZ)
            if (stepXNow && stepYNow && stepZNow && dx != 0 && dy != 0 && dz != 0) { // 3-way tie
                // Add intermediate blocks to ensure no clipping through corners
                blocks.add(new BlockPos(ix + stepX, iy, iz));
                blocks.add(new BlockPos(ix, iy + stepY, iz));
                blocks.add(new BlockPos(ix, iy, iz + stepZ));
                blocks.add(new BlockPos(ix + stepX, iy + stepY, iz));
                blocks.add(new BlockPos(ix + stepX, iy, iz + stepZ));
                blocks.add(new BlockPos(ix, iy + stepY, iz + stepZ));
                // Then the diagonal
                ix += stepX; iy += stepY; iz += stepZ;
                tMaxX += tDeltaX; tMaxY += tDeltaY; tMaxZ += tDeltaZ;
            } else if (stepXNow && stepYNow && dx != 0 && dy != 0) {
                blocks.add(new BlockPos(ix + stepX, iy, iz));
                blocks.add(new BlockPos(ix, iy + stepY, iz));
                ix += stepX; iy += stepY;
                tMaxX += tDeltaX; tMaxY += tDeltaY;
            }
            else if (stepXNow && stepZNow && dx != 0 && dz != 0) {
                blocks.add(new BlockPos(ix + stepX, iy, iz));
                blocks.add(new BlockPos(ix, iy, iz + stepZ));
                ix += stepX; iz += stepZ;
                tMaxX += tDeltaX; tMaxZ += tDeltaZ;
            }
            else if (stepYNow && stepZNow && dy != 0 && dz != 0) {
                blocks.add(new BlockPos(ix, iy + stepY, iz));
                blocks.add(new BlockPos(ix, iy, iz + stepZ));
                iy += stepY; iz += stepZ;
                tMaxY += tDeltaY; tMaxZ += tDeltaZ;
            }
            else if (stepXNow && dx != 0) {
                tMaxX += tDeltaX;
                ix += stepX;
            }
            else if (stepYNow && dy != 0) {
                tMaxY += tDeltaY;
                iy += stepY;
            }
            else if (stepZNow && dz != 0) {
                tMaxZ += tDeltaZ;
                iz += stepZ;
            } else {
                // This case should ideally not be reached if start != end and dx,dy,dz are handled.
                // It might indicate that we've reached the target along one or more zero-delta axes.
                boolean progressMade = false;
                if (dx != 0 && ix != end.getX()) { tMaxX += tDeltaX; ix += stepX; progressMade = true;}
                else if (dy != 0 && iy != end.getY()) { tMaxY += tDeltaY; iy += stepY; progressMade = true;}
                else if (dz != 0 && iz != end.getZ()) { tMaxZ += tDeltaZ; iz += stepZ; progressMade = true;}

                if (!progressMade) { // If no progress can be made, break to avoid infinite loop
                    LOGGER.warn("getBlocksBetween stuck or reached end: ({},{},{}) to ({},{},{}) current ({},{},{}) tMax ({},{},{})", start.getX(),start.getY(),start.getZ(), end.getX(),end.getY(),end.getZ(), ix,iy,iz, tMaxX, tMaxY, tMaxZ);
                    break;
                }
            }
        }
        // Ensure the final block is unique if it was already added
        if (!blocks.isEmpty() && !blocks.getLast().equals(new BlockPos(ix,iy,iz)) && (ix==end.getX() && iy==end.getY() && iz==end.getZ())) {
            blocks.add(new BlockPos(ix,iy,iz));
        }


        return blocks;
    }

    private boolean canJumpFrom(BlockState stateBelowFeet) { // Renamed parameter for clarity
        if (stateBelowFeet == null) return false;

        // Standard jumpable surfaces
        if (stateBelowFeet.isSideSolidFullSquare(world, BlockPos.ORIGIN, Direction.UP) // BlockPos.ORIGIN is fine for state check
                || stateBelowFeet.getBlock() instanceof StairsBlock
                || stateBelowFeet.getBlock() instanceof FarmlandBlock) {
            return true;
        }

        // Allow jumping if the block below feet is a ladder (representing standing on its top edge)
        return stateBelowFeet.getBlock() instanceof LadderBlock;
    }

    /** If horiz has no solid block beneath, scan down up to maxDrop. */
    private BlockPos findGroundBelow(BlockPos horiz) {
        // If the current horizontal position is a ladder, it's its own "ground" for pathfinding purposes
        if (isLadder(horiz) && isSpaceClearForLadder(horiz)) {
            LOGGER.debug("Position {} is a ladder, considering it as ground.", horiz);
            return horiz;
        }

        for (int d = 0; d <= maxDrop; d++) {
            BlockPos below = horiz.down(d + 1);
            if (below.getY() < world.getBottomY()) {
                LOGGER.debug("Position {} is below world level", below);
                break;
            }

            if (!cache.isWithinCacheBounds(below)) {
                LOGGER.debug("Position of ground below {} is outside cache bounds", below);
                return null;
            }

            if (hasTopCollision(below)) {
                BlockPos result = below.up();
                if (isSpaceClear(result) || (isLadder(result) && isSpaceClearForLadder(result))) { // Allow standing in ladder space too
                    LOGGER.debug("Found ground at {}, returning position just above: {}", below, result);
                    return result;
                } else {
                    LOGGER.debug("Found ground at {} but space at {} is not clear", below, result);
                }
            }
        }
        LOGGER.debug("No suitable ground found below {} within max drop {}", horiz, maxDrop);
        return null;
    }

    /** Ensure that the two-block-tall space at pos is free. */
    private boolean isSpaceClear(BlockPos pos) {
        if (!cache.isWithinCacheBounds(pos) || !cache.isWithinCacheBounds(pos.up())) {
            LOGGER.debug("Position {} or {} (isSpaceClear) is outside cache bounds", pos, pos.up());
            return false;
        }

        BlockState blockAt = cache.getBlockState(pos);
        BlockState blockAbove = cache.getBlockState(pos.up());
        if (blockAt == null || blockAbove == null) {
            LOGGER.debug("Missing block state at {} or {}", pos, pos.up());
            return false;
        }

        // Feet can be in air, passable plants, thin blocks, or a ladder
        boolean feetClear = blockAt.isReplaceable() // More general check for replaceable blocks
                || blockAt.getBlock() instanceof CarpetBlock
                || (blockAt.getBlock() == Blocks.SNOW && blockAt.get(SnowBlock.LAYERS) <= 3)
                || isLadder(pos); // Feet can be in a ladder block

        // Head can be in air, passable plants, or a ladder
        boolean headClear = blockAbove.isReplaceable()
                || isLadder(pos.up()); // Head can be in a ladder block

        // If feet are in a ladder, head must also be in a ladder or air/replaceable
        if (isLadder(pos) && !headClear) {
            // If feet are in a ladder, but head is blocked by a non-ladder/non-air block, it's not clear
            // This check is now more implicitly handled by isSpaceClearForLadder which checks the block above a ladder
            // However, keeping a direct check here for general isSpaceClear can be beneficial.
            if (!(blockAbove.isAir() || blockAbove.isReplaceable() || isLadder(pos.up()))) {
                LOGGER.debug("Space not clear at {}: feet in ladder, but head blocked by {}", pos, blockAbove);
                return false; // Redundant if isSpaceClearForLadder is used correctly for ladder nodes
            }
        }


        boolean result = feetClear && headClear;
        if (!result) {
            LOGGER.debug("Space not clear at {}: block at position is {}, block above is {}. FeetClear: {}, HeadClear: {}",
                    pos, blockAt, blockAbove, feetClear, headClear);
        }
        return result;
    }

    /**
     * @return true if there is any collision geometry at this block's top face.
     */
    private boolean hasTopCollision(BlockPos pos) {
        BlockState state = cache.getBlockState(pos);
        if (state == null) return false;

        if (state.getBlock() instanceof LadderBlock) return false; // Ladders don't have top collision for standing

        // Check for blocks that are solid on top or specific standable non-solid blocks
        return state.isSideSolidFullSquare(world, pos, Direction.UP)
                || state.getBlock() instanceof FarmlandBlock
                || (state.getBlock() instanceof SlabBlock && state.get(SlabBlock.TYPE) == SlabType.TOP) // Only top slabs are fully solid on top
                || (state.getBlock() instanceof SnowBlock && state.get(SnowBlock.LAYERS) == SnowBlock.MAX_LAYERS) // Full snow block
                || state.getBlock() instanceof StairsBlock && state.get(StairsBlock.HALF) == BlockHalf.TOP; // Top half of stairs
    }

    /** Cost: use Euclidean or custom if you want to penalize drops/jumps. */
    private double movementCost(BlockPos from, BlockPos to) {
        double baseCost = Math.sqrt(from.getSquaredDistance(to));
        int yDiff = to.getY() - from.getY();
        double finalCost;

        BlockState fromState = cache.getBlockState(from);
        BlockState toState = cache.getBlockState(to);

        boolean movingToLadder = (toState != null && toState.getBlock() instanceof LadderBlock);
        boolean movingFromLadder = (fromState != null && fromState.getBlock() instanceof LadderBlock);
        boolean onLadderSegment = (movingToLadder && movingFromLadder && from.getX() == to.getX() && from.getZ() == to.getZ()); // Moving purely vertically on a ladder
        boolean enteringOrExitingLadder = (movingToLadder != movingFromLadder);


        double totalDist   = Math.sqrt(start.getSquaredDistance(goal));
        double distSoFar   = Math.sqrt(start.getSquaredDistance(from));
        double fraction    = (totalDist == 0) ? 0 : Math.min(1.0, distSoFar / totalDist);

        double jumpMult = 1.0 + 0.5 * fraction;
        double ladderClimbCostMultiplier = 1.05; // Slightly cheaper than diagonal, more than flat
        double ladderTransitionCostMultiplier = 1.1; // Cost for getting on/off ladder

        if (onLadderSegment) { // Climbing up or down a ladder segment
            finalCost = baseCost * ladderClimbCostMultiplier;
        } else if (enteringOrExitingLadder) {
            finalCost = baseCost * ladderTransitionCostMultiplier;
        } else if (yDiff < 0) { // Dropping down
            finalCost = baseCost * 0.8;
        } else if (yDiff > 0) { // Jumping up
            finalCost = baseCost * jumpMult;
        } else { // Flat movement
            finalCost = baseCost;
        }

        LOGGER.debug("Movement cost from {} to {}: {}. Base: {}, YDiff: {}, ToLadder: {}, FromLadder: {}, OnLadderSeg: {}, EnterExitLadder: {}",
                from, to, finalCost, baseCost, yDiff, movingToLadder, movingFromLadder, onLadderSegment, enteringOrExitingLadder);
        return finalCost;
    }

    private double estimateDistance(BlockPos start, BlockPos end) {
        // Euclidean distance is generally a good admissible heuristic.
        // Manhattan can sometimes be better if diagonal movement is heavily penalized or impossible.
        return Math.sqrt(start.getSquaredDistance(end));
    }

    private boolean isOnGround(BlockPos pos) {
        if (isLadder(pos) && isSpaceClearForLadder(pos)) return true; // On a ladder is considered "grounded" for path purposes

        BlockPos below = pos.down();
        if (!cache.isWithinCacheBounds(below)) {
            return false;
        }

        BlockState state = cache.getBlockState(below);
        return state != null && (state.isSideSolidFullSquare(world, below, Direction.UP)
                || state.getBlock() instanceof StairsBlock
                || state.getBlock() instanceof SlabBlock
                || (state.getBlock() instanceof SnowBlock && state.get(SnowBlock.LAYERS) == SnowBlock.MAX_LAYERS)
                || state.getBlock() instanceof CarpetBlock
                || state.getBlock() instanceof FarmlandBlock);
    }

    private List<BlockPos> reconstructPath(Node goalNode) {
        List<BlockPos> path = new ArrayList<>();
        Node current = goalNode;
        while (current != null) {
            path.addFirst(current.getPos());
            current = current.getParent();
        }
        LOGGER.info("Reconstructed path of length {}", path.size());
        return path;
    }

    // Node class for A* algorithm
    private static class Node {
        private final BlockPos pos;
        private final double g; // Cost from start
        private final double h; // Estimated cost to goal
        private final Node parent;

        public Node(BlockPos pos, double g, double h) {
            this.pos = pos;
            this.g = g;
            this.h = h;
            this.parent = null;
        }

        public Node(BlockPos pos, double g, double h, Node parent) {
            this.pos = pos;
            this.g = g;
            this.h = h;
            this.parent = parent;
        }

        public BlockPos getPos() {
            return pos;
        }

        public double getG() {
            return g;
        }

        public double getF() {
            return g + h;
        }

        public Node getParent() {
            return parent;
        }
    }
}